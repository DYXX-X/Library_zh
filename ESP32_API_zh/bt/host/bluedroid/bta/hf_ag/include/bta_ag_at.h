/******************************************************************************
 * 版权所有（C）2004-2012 Broadcom Corporation
 *
 *  根据Apache许可证2.0版（“许可证”）获得许可；除非符合许可证，否则不得使用此文件。您可以在以下地址获取许可证副本：
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  除非适用法律要求或书面同意，否则根据许可证分发的软件是按“原样”分发的，无任何明示或暗示的担保或条件。有关许可证下权限和限制的具体语言，请参阅许可证。
 *
 ******************************************************************************/

/******************************************************************************
 * BTA AG AT命令解释器的接口文件。
 *
 ******************************************************************************/
#ifndef BTA_AG_AT_H
#define BTA_AG_AT_H

#include "stack/bt_types.h"
#include "common/bt_target.h"

/*****************************************************************************
**  常量
*****************************************************************************/
#if (BTA_AG_INCLUDED == TRUE)

/* AT命令参数功能*/
#define BTA_AG_AT_NONE          0x01        /* 没有争论*/
#define BTA_AG_AT_SET           0x02        /* 设定值*/
#define BTA_AG_AT_READ          0x04        /* 读取值*/
#define BTA_AG_AT_TEST          0x08        /* 测试值范围*/
#define BTA_AG_AT_FREE          0x10        /* 自由形式论证*/

/* AT命令参数格式*/
#define BTA_AG_AT_STR           0           /* 一串*/
#define BTA_AG_AT_INT           1           /* 整数*/

/*****************************************************************************
**  数据类型
*****************************************************************************/

/* AT命令表元素*/
typedef struct
{
    const char  *p_cmd;         /* AT命令字符串*/
    UINT8       arg_type;       /* 允许的参数类型语法*/
    UINT8       fmt;            /* arg是int还是string*/
    UINT8       min;            /* int arg的最小值*/
    INT16       max;            /* int arg的最大值*/
} tBTA_AG_AT_CMD;

/* 解析命令时执行的回调函数*/
typedef void (tBTA_AG_AT_CMD_CBACK)(void *p_user, UINT16 cmd, UINT8 arg_type,
                                    char *p_arg, INT16 int_arg);

/* 执行回调函数以发送“ERROR”结果代码*/
typedef void (tBTA_AG_AT_ERR_CBACK)(void *p_user, BOOLEAN unknown, char *p_arg);

/* AT命令解析控制块*/
typedef struct
{
    tBTA_AG_AT_CMD          *p_at_tbl;      /* AT命令表*/
    tBTA_AG_AT_CMD_CBACK    *p_cmd_cback;   /* 命令回调*/
    tBTA_AG_AT_ERR_CBACK    *p_err_cback;   /* 错误回调*/
    void                    *p_user;        /* 用户定义的数据*/
    char                    *p_cmd_buf;     /* 临时分析缓冲区*/
    UINT16                  cmd_pos;        /* 临时缓冲区中的位置*/
    UINT16                  cmd_max_len;    /* 要分配的临时缓冲区长度*/
    UINT8                   state;          /* 解析状态*/
} tBTA_AG_AT_CB;

/*****************************************************************************
**  功能原型
*****************************************************************************/

/*****************************************************************************
** 函数bta_ag_at_init
**
** 说明初始化AT命令解析器控制块。
**
** 返回void
**
*****************************************************************************/
extern void bta_ag_at_init(tBTA_AG_AT_CB *p_cb);

/*****************************************************************************
** 函数bta_ag_at_reinit
**
** 说明重新初始化AT命令解析器控制块。此函数重置AT命令解析器状态并释放任何GKI缓冲区。
**
** 返回void
**
*****************************************************************************/
extern void bta_ag_at_reinit(tBTA_AG_AT_CB *p_cb);

/*****************************************************************************
** 函数bta_ag_at_parse
**
** 说明分析AT命令。此函数将获取输入字符串，并根据在控制块中传递的AT命令表解析AT命令。
**
** 返回void
**
*****************************************************************************/
extern void bta_ag_at_parse(tBTA_AG_AT_CB *p_cb, char *p_buf, UINT16 len);

#endif /* #如果（BTA_AG_INCLUDE==真）*/

#endif /* BTA_AG_AT_H */

