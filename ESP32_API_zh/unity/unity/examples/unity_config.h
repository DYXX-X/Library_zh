/* Unity配置截至2016年5月11日，ThrowTheSwitch/Unity提交837c529更新：2016年12月29日另请参阅：Unity/docs/UnityConfigurationGuide.pdf
 *
 * Unity被设计为可以在C编译器所针对的几乎所有对象上运行。如果这可以在零配置的情况下完成，那就太棒了。虽然有一些目标接近这个梦想，但遗憾的是，它并不普遍。您可能需要至少两个本文档中描述的配置选项。
 *
 * Unity的所有配置选项都是“#defines”。其中大多数都是简单的定义。有几个是带有参数的宏。他们住在单位内部。h头文件。除非您确实需要，否则我们不一定建议您打开该文件。该文件证明了跨平台库的构建具有挑战性。从更积极的角度来看，这也证明了大量的复杂性可以集中在一个地方，以便在其他地方提供更一致和简单的体验。
 *
 * 使用这些选项无论您使用的是特定于目标的编译器、模拟器还是本机编译器。无论哪种情况，您都可以选择配置这些选项：
 *
 *  1.因为这些选项是通过C定义指定的，所以您可以通过命令行编译器标志将这些选项中的大部分传递给编译器。即使您使用的是一个嵌入式目标，迫使您在所有配置中都使用其强大的IDE，您的项目中也会有一个地方为编译器配置定义。2.可以创建自定义`unity_config。h`配置文件（存在于工具链的搜索路径中）。在此文件中，您将列出特定于目标的定义和宏。您只需定义`UNITY_INCLUDE_CONFIG_H`，UNITY将依赖`UNITY_CONFIG。对于它可能需要的任何进一步的定义。
 */

#ifndef UNITY_CONFIG_H
#define UNITY_CONFIG_H

/* *************************自动整数类型***************************C的整数概念因目标而异。C标准有关于与目标微处理器的寄存器大小匹配的“int”的规则。它有关于“int”及其大小与其他整数类型的关系的规则。一个目标上的“int”可能是16位，而另一个目标可能是64位。与C99或更高版本兼容的编译器中有更多特定类型，但这肯定不是您可能遇到的所有编译器。因此，Unity有许多功能可帮助调整自身以匹配所需的整数大小。它从尝试自动执行开始。
 **************************************************************************** */

/* 猜你的类型的第一次尝试是检查“limits.h”。某些编译器不支持`stdint。“h”可以包括“limits.h”。如果您不希望Unity检查此文件，请定义它以使其跳过包含。Unity查看了自C89以来可用的UINT_MAX和ULONG_MAX。
 */
/* #定义UNITY_EXCLUDE_LIMITS_H*/

/* Unity猜测类型的第二件事是检查“stdint.h”。该文件定义了“UINTPTR_MAX”，自C99以来，Unity可以利用它来了解您的系统。您可能不希望它这样做，或者您的系统不支持“stdint.h”。如果是这样的话，你需要定义一下。这样，Unity就会知道跳过包含此文件，并且不会留下编译器错误。
 */
/* #定义UNITY_EXCLUDE_STDINT_H*/

/* **********************手动整数类型定义***********************如果您禁用了上述所有自动选项，则必须自己进行配置。如果你不喜欢默认值，你只需要指定一些定义。
 **************************************************************************** */

 /* 将其定义为“int”在系统中占用的位数。如果未自动检测，默认值为32位。
 *
 * 例子：
 */
/* #定义UNITY_INT_WIDTH 16*/

/* 将其定义为“long”在系统中占用的位数。如果未自动检测，默认值为32位。这用于确定您的系统可以处理什么样的64位支持。是否需要指定“long”或“long-long”才能获得64位值。在16位系统上，此选项将被忽略。
 *
 * 例子：
 */
/* #定义UNITY_LONG_WIDTH 16*/

/* 将其定义为指针在系统中占用的位数。如果未自动检测，默认值为32位。如果您收到了关于从指针强制转换的难看的编译器警告，那么应该看看这个。
 *
 * 例子：
 */
/* #定义UNITY_POINTER_WIDTH 64*/

/* 如果Unity自动检测到64位，或者“int”、“long”或指针宽度大于32位，Unity将自动包含64位支持。如果没有其他选项为您提供64位支持，请定义此选项以启用64位支持。在小目标上启用64位支持可能会对大小和速度产生重大影响，因此如果不需要，请不要定义它。
 */
/* #定义UNITY_INCLUDE_64*/


/* ***************************浮点类型****************************在嵌入式世界中，目标根本不支持浮点运算或支持仅限于单精度的情况并不罕见。我们可以随时猜测整数的大小，因为整数总是至少有一种大小。另一方面，浮点有时根本不可用。尝试在这些平台上包含“float.h”将导致错误。这使得手动配置成为唯一的选项。
 **************************************************************************** */

 /* 默认情况下，Unity猜测您需要单精度浮点支持，但不需要双精度。使用此处的include和exclude选项可以很容易地更改其中任何一个。根据您的需要，您可以既不包括，也不包括浮动，或两者都包括。
  */
/* #定义UNITY_EXCLUDE_FLOAT*/
/* #定义UNITY_INCLUDE_DOUBLE*/
/* #定义UNITY_EXCLUDE_DOUBLE*/

/* 对于已启用的功能，以下浮点选项也可用。
 */

/* Unity的目标是尽可能小的占地面积，并避免大多数标准库调用（一些嵌入式平台没有标准库！）。因此，它打印整数值的例程是极简的，并且是手工编码的。为了保持Unity的通用性，我们最终选择开发自己的浮点打印例程。然而，故障期间显示浮点值是可选的。默认情况下，Unity将打印浮点断言失败的实际结果。因此，失败的断言将生成类似“预期4.0为4.25”的消息。如果您希望浮点断言的失败消息不那么冗长，请使用此选项给出失败消息“Values Not Within Delta”并调整二进制大小。
 */
/* #定义UNITY_EXCLUDE_FLOAT_PRINT*/

/* 如果启用，Unity假设您希望“FLOAT”断言比较标准C浮点。如果编译器支持特殊浮点类型，则始终可以使用此定义重写此行为。
 *
 * 例子：
 */
/* #定义UNITY_FLOAT_TYPE float16_t*/

/* 如果启用，Unity假设您希望“DOUBLE”断言比较标准C双精度。如果要更改此选项，可以使用此选项指定其他内容。例如，将“UNITY_DOUBLE_TYPE”定义为“long DOUBLE”可以在64位处理器上启用庞大的浮点类型，而不是标准的“DOUBLE”。
 *
 * 例子：
 */
/* #定义UNITY_DOUBLE_TYPE长DOUBLE*/

/* 如果您查找《UNITY断言指南》中记录的“UNITY_ASSERT_EQUAL_FLOAT”和“UNITY_ASSERT_EQUAL-DOUBLE”，您会发现它们并不是真的断言两个值相等，而是两个值“足够接近”相等。“足够接近”由这些精度配置选项控制。如果您使用的是32位浮点和/或64位双精度（大多数处理器上的正常情况），则无需更改这些选项。它们都被设置为在任一方向上提供大约1个有效位。浮点精度为0.00001，而双精度为10^-12。有关如何工作的详细信息，请参阅Unity断言指南的附录。
 *
 * 例子：
 */
/* #定义UNITY_FLOAT_PRECISION 0.001f*/
/* #定义UNITY_DOUBLE_PRECISION 0.001f*/


/* ***************************工具集自定义***************************除了上面列出的选项外，还有许多其他选项可以方便地为您的特定工具链自定义Unity的行为。您可能不需要接触这些平台中的任何一个，但某些平台，特别是在模拟器中运行的平台，可能需要跳过额外的环才能正常运行。这些宏在这些情况下会有所帮助。
 **************************************************************************** */

/* 默认情况下，Unity在运行时将其结果打印到“stdout”。这在大多数使用本机编译器进行测试的情况下都非常好。它在一些模拟器上也可以工作，只要它们将“stdout”路由回命令行即可。然而，有时模拟器会缺少对转储结果的支持，或者出于其他原因，您希望将结果路由到其他地方。在这些情况下，应该定义`UNITY_OUTPUT_CHAR`宏。此宏一次只接受一个字符（作为“int”，因为这是最常用的标准C“putchar”函数的参数类型）。你可以用你喜欢的任何函数调用来替换它。
 *
 * 示例：假设您被迫在没有“stdout”选项的嵌入式处理器上运行测试套件。您决定将测试结果输出路由到您编写的自定义串行“RS232_putc（）”函数，如下所示：
 */
/* #定义UNITY_OUTPUT_CHAR（a）RS232_putc（a）*/
/* #定义UNITY_OUTPUT_CHAR_HEADER_DECLARATION RS232_putc（int）*/
/* #定义UNITY_OUTPUT_FLUSH（）RS232_FLUSH（）*/
/* #定义UNITY_OUTPUT_FLUSH_HEADER_DECLATION RS232_FLUSH（void）*/
/* #定义UNITY_OUTPUT_START（）RS232_config（115200,1,8,0）*/
/* #定义UNITY_OUTPUT_COMPLETE（）RS232_close（）*/

/* 对于某些目标，Unity可以使其他需要的“setUp（）”和“tearDown（）”函数可选。这对于测试编写者来说是一个很好的方便，因为“setUp”和“tearDown”通常不会做任何事情。如果您使用的是gcc或clang，则会自动为您定义此选项。如果其他编译器支持称为弱函数的C特性，它们也可以支持这种行为。弱函数是编译到可执行文件_unless中的函数，同一函数的非弱版本在其他地方定义。如果找到非弱版本，则忽略该弱版本，就像它从未存在过一样。如果您的编译器支持此功能，您可以通过将“Unity_SUPPORT_WEAK”定义为需要应用的函数属性来将函数标识为弱函数，从而让Unity知道。如果您的编译器缺少对弱函数的支持，您将始终需要定义“setUp”和“tearDown”函数（尽管它们可能是空的，而且常常是空的）。此功能最常见的选项有：
 */
/* #定义UNITY_SUPPORT_WEAK弱*/
/* #定义UNITY_SUPPORT_WEAK __attribute__（（弱））*/
/* #定义UNITY_NO_WEAK*/

/* 有些编译器要求将自定义属性分配给指针，如“near”或“far”。在这些情况下，您可以通过使用您想要的属性定义此选项，为Unity提供一个安全的默认值。
 *
 * 例子：
 */
/* #定义UNITY_PTR_ATTRIBUTE__ATTRIBUTE__（（远））*/
/* #在附近定义UNITY_PTR_ATTRIBUTE*/

/* 以详细模式执行时打印每个测试的执行时间
 *
 * 例子：
 *
 * 测试通过（10 ms）
 */
/* #定义UNITY_INCLUDE_EXEC_TIME*/

#endif /* UNITY_CONFIG_H */

